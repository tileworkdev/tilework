@using System.Linq
@using Tilework.LoadBalancing.Models

<div class="d-flex flex-column mud-width-full">
    <MudText Typo="Typo.subtitle2" Class="mb-2">@Name</MudText>
    <MudChart ChartType="ChartType.Line"
              Width="100%"
              Height="100%"
              XAxisLabels="@_chartLabels"
              ChartSeries="@_series"
              ChartOptions="@_chartOptions"
              AxisChartOptions="@_axisChartOptions" />
</div>

@code {
    [Parameter]
    public string Name { get; set; } = string.Empty;
    [Parameter]
    public Dictionary<DateTime, double> Data { get; set; } = new();

    private readonly ChartOptions _chartOptions = new ChartOptions {
        ShowLegend = false,
        LineStrokeWidth = 2,
        ChartPalette = [Colors.Green.Darken4]
    };
    private readonly AxisChartOptions _axisChartOptions = new AxisChartOptions();
    private string[] _chartLabels = Array.Empty<string>();
    private List<ChartSeries> _series = new();

    protected override void OnParametersSet()
    {
        BuildChartData();
    }

    private void BuildChartData()
    {
        var orderedData = Data.OrderBy(kv => kv.Key).ToList();
        if (orderedData.Count == 0)
        {
            _chartLabels = Array.Empty<string>();
            _series = new List<ChartSeries>();
            return;
        }

        var times = orderedData.Select(d => d.Key).ToList();
        var duration = times.Last() - times.First();

        const int targetLabelCount = 4;
        var useDayLabels = duration >= TimeSpan.FromHours(48);
        TimeSpan interval;
        DateTime nextLabelTime;
        if (useDayLabels)
        {
            interval = TimeSpan.FromDays(1);
            nextLabelTime = AlignToNextMidday(times.First());
        }
        else
        {
            var approxIntervalMinutes = Math.Max(1, duration.TotalMinutes / targetLabelCount);
            var intervalMinutes = GetRoundedIntervalMinutes(approxIntervalMinutes);
            interval = TimeSpan.FromMinutes(intervalMinutes);
            nextLabelTime = AlignToNextInterval(times.First(), interval);
        }

        _chartLabels = new string[orderedData.Count];
        for (var i = 0; i < orderedData.Count; i++)
        {
            var current = times[i];
            var label = string.Empty;

            if (current >= nextLabelTime)
            {
                while (current >= nextLabelTime)
                {
                    nextLabelTime = nextLabelTime.Add(interval);
                }

                label = FormatLabel(nextLabelTime.Subtract(interval), useDayLabels);
            }

            _chartLabels[i] = label;
        }

        _series = new List<ChartSeries>
        {
            new ChartSeries
            {
                Name = Name,
                Data = orderedData.Select(d => (double)d.Value).ToArray()
            }
        };
    }

    private static int GetRoundedIntervalMinutes(double approxMinutes)
    {
        int[] allowed = { 1, 2, 5, 10, 15, 30, 60, 120, 240, 720, 1440 };
        foreach (var candidate in allowed)
        {
            if (approxMinutes <= candidate)
            {
                return candidate;
            }
        }
        return allowed.Last();
    }

    private static DateTime AlignToNextInterval(DateTime time, TimeSpan interval)
    {
        var ticks = ((time.Ticks + interval.Ticks - 1) / interval.Ticks) * interval.Ticks;
        return new DateTime(ticks, time.Kind);
    }

    private static DateTime AlignToNextMidday(DateTime time)
    {
        var midday = time.Date.AddHours(12);
        return time <= midday ? midday : midday.AddDays(1);
    }

    private static string FormatLabel(DateTime labelTime, bool useDayLabels)
    {
        return useDayLabels
            ? labelTime.ToString("ddd dd")
            : labelTime.ToString("HH:mm");
    }
}
